version: "3.9"

x-celery-healthcheck: &celery-healthcheck
  healthcheck:
    test: "celery -b redis://${DOCKER_REDIS_HOST}:${DOCKER_REDIS_PORT} inspect ping || exit 1"
    interval: 10s
    timeout: 10s
    retries: 2

x-backend: &backend
  container_name: frege-backend
  image: frege-backend-image
  build: ./backend
  hostname: backend
  command: >
    sh -c "python manage.py migrate --noinput
    && python manage.py initadmin
    && python manage.py runserver
    0.0.0.0:${DOCKER_BACKEND_PORT}"
  ports:
    - "${DOCKER_EGRESS_IP}:${DOCKER_BACKEND_PORT}:${DOCKER_BACKEND_PORT}"
  depends_on:
    - frege-postgres
    - frege-redis
  volumes:
    - ./backend:/app
    - frege_tmp:${DJANGO_DOWNLOAD_PATH}
  networks:
    - frege-main
  profiles: [ "dev", "local-be-dev" ]
  restart: on-failure
  env_file:
    - .env

services:

# === [Common] ===

  frege-redis:
    container_name: frege-redis
    hostname: frege-redis
    image: redis:7.0
    networks:
      - frege-main
    expose:
      - "${DOCKER_REDIS_PORT}"
    profiles: [ "dev", "prod", "local-be-dev" ]
    restart: on-failure
    healthcheck:
      test: "redis-cli ping || exit 1"
      interval: 10s
      timeout: 10s
      retries: 2

  frege-postgres:
    container_name: frege-postgres
    hostname: frege-postgres
    image: postgres:14.2
    environment:
      - POSTGRES_USER=${DJANGO_DATABASE_USER}
      - POSTGRES_PASSWORD=${DJANGO_DATABASE_PASSWORD}
      - POSTGRES_DB=${DJANGO_DATABASE_NAME}
    networks:
      - frege-main
    expose:
      - "${DOCKER_POSTGRES_PORT}"
    ports:
      - "${DOCKER_POSTGRES_PORT}:${DOCKER_POSTGRES_PORT}"
    profiles: [ "dev", "prod", "local-be-dev" ]
    restart: on-failure
    volumes:
      - frege_postgresql_data:/var/lib/postgresql/data
    # Removing code below is a workaround for 'role "root" does not exist' error.
    # TODO: modification of healthcheck code below to error-free form.
    #healthcheck:
    #  test: "pg_isready -p ${DOCKER_POSTGRES_PORT} || exit 1"
    #  interval: 10s
    #  timeout: 10s
    #  retries: 2

  frege-prometheus:
    image: prom/prometheus:v2.35.0
    container_name: frege-prometheus
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "${DOCKER_PROMETHEUS_PORT}:${DOCKER_PROMETHEUS_PORT}"
    expose:
      - ${DOCKER_PROMETHEUS_PORT}
    networks:
      - frege-main
    profiles: [ "dev", "prod" ]
    restart: on-failure
    healthcheck:
      test: "wget -nv -t1 --spider http://localhost:${DOCKER_PROMETHEUS_PORT} || exit 1"
      interval: 10s
      timeout: 10s
      retries: 2

  frege-loki:
    image: grafana/loki:2.7.4
    user: "1000"
    container_name: frege-loki
    ports:
      - 3100:3100
    volumes:
      - ./loki/data:/loki
      # - ./loki/loki-config.yaml:/etc/loki/local-config.yaml
    # command: -config.file=/etc/loki/local-config.yaml
    networks:
      - frege-main
    profiles: [ "dev", "prod" ]

  frege-promtail:
    image: grafana/promtail:2.6.1
    container_name: frege-promtail
    depends_on:
      - frege-loki
    volumes:
      - ./loki/promtail-config.yaml:/etc/promtail/config.yml
      - /var/run/docker.sock:/var/run/docker.sock
      - /var/lib/docker/containers:/var/lib/docker/containers
    networks:
      - frege-main
    profiles: [ "dev", "prod" ]

# === [Dev] ===

  frege-backend-dev:
    <<: *backend
    healthcheck:
      test: "curl -f http://localhost:${DOCKER_BACKEND_PORT}/ht || exit 1"
      interval: 10s
      timeout: 10s
      retries: 2

  frege-flower-dev:
    <<: *backend
    container_name: frege-flower-dev
    command: celery -A frege flower
    ports:
      - 5555:5555
    expose:
      - 5555
    environment:
      CELERY_BROKER_URL: redis://frege-redis
      CELERY_RESULT_BACKEND: redis://frege-redis
    depends_on:
      - frege-celery-worker-dev
      - frege-celery-downloads-worker-dev
      - frege-celery-crawl-worker-dev
      - frege-redis
    profiles: [ "dev" ]
    healthcheck:
      test: "curl -f http://localhost:${DOCKER_FLOWER_PORT} || exit 1"
      interval: 10s
      timeout: 10s
      retries: 2

  # Autoreload on code change won't work without this setup
  #
  # frege-celery-worker-dev:
  #   <<: [*backend, *celery-healthcheck]
  #   container_name: frege-celery-worker-dev
  #   ports: []
  #   command: sh -c "python3 manage.py celery_dev_autoreload"
  #   profiles: [ "dev" ]

  frege-celery-crawl-worker-dev:
      <<: [*backend, *celery-healthcheck]
      container_name: frege-celery-crawl-worker-dev
      ports: []
      command: celery -A frege worker -Q crawl -l debug --concurrency=${CELERY_WORKER_CRAWL_CONCURRENCY} -n worker_crawl
      profiles: [ "dev", "local-be-dev" ]

  frege-celery-downloads-worker-dev:
    <<: [*backend, *celery-healthcheck]
    container_name: frege-celery-downloads-worker-dev
    ports: []
    command: celery -A frege worker -Q downloads -l debug --concurrency=${CELERY_WORKER_DOWNLOADS_CONCURRENCY} -n worker_downloads
    profiles: [ "dev", "local-be-dev" ]

  frege-celery-worker-dev:
    <<: [*backend, *celery-healthcheck]
    container_name: frege-celery-worker-dev
    ports: []
    command: celery -A frege worker -Q celery -l debug --concurrency=${CELERY_WORKER_BASE_CONCURRENCY} -n worker_celery
    profiles: [ "dev", "local-be-dev" ]

  frege-grafana-dev: &grafana
    image: grafana/grafana:8.5.2
    container_name: frege-grafana-dev
    depends_on:
      - frege-prometheus
      - frege-postgres
      - frege-loki
      - frege-promtail
    volumes:
      - frege_grafana_storage:/var/lib/grafana
      - ./grafana/provisioning/dashboards:/etc/grafana/provisioning/dashboards
      - ./grafana/provisioning/datasources:/etc/grafana/provisioning/datasources
    environment:
      - GF_USERS_DEFAULT_THEME=dark
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_USERS_ALLOW_ORG_CREATE=false
      - GF_AUTH_ANONYMOUS_ENABLED=true
      - GF_SECURITY_ALLOW_EMBEDDING=true
      - GF_SERVER_ROOT_URL=%(protocol)s://%(domain)s:%(http_port)s/grafana/
      - GF_SERVER_SERVE_FROM_SUB_PATH=true
    ports:
      - ${DOCKER_GRAFANA_PORT}:${DOCKER_GRAFANA_PORT}
    networks:
      - frege-main
    env_file:
      - .env
    profiles: [ "dev" ]
    restart: on-failure
    healthcheck:
      test: "wget -nv -t1 --spider http://localhost:${DOCKER_GRAFANA_PORT}/api/health || exit 1"
      interval: 10s
      timeout: 10s
      retries: 2

  frege-frontend-dev: &frontend
    container_name: frege-frontend-dev
    hostname: frege-frontend-dev
    build:
      context: frontend
      dockerfile: Dockerfile
    environment:
      - PORT=${DOCKER_FRONTEND_PORT}
      - REACT_APP_DOCKER_GRAFANA_HOST=frege-grafana-dev
      - REACT_APP_DOCKER_GRAFANA_PORT=3000
      - DOCKER_FLOWER_HOST=frege-flower-dev
      - DOCKER_FLOWER_PORT=5555
      - DJANGO_SUPERUSER_USERNAME=django_admin
      - DJANGO_SUPERUSER_PASSWORD=pass
      - CHOKIDAR_USEPOLLING=true
    volumes:
      - /app/node_modules
      - ./frontend:/app
    command: npm start
    ports:
      - ${DOCKER_FRONTEND_PORT}:${DOCKER_FRONTEND_PORT}
    depends_on:
      - frege-grafana-dev
    networks:
      - frege-main
    profiles: [ "dev" ]
    restart: on-failure
    healthcheck:
      test: "wget -nv -t1 --spider http://localhost:${DOCKER_FRONTEND_PORT} || exit 1"
      interval: 10s
      timeout: 10s
      retries: 2
      start_period: 40s

# === [Prod] ===

  frege-frontend-prod:
    <<: *frontend
    container_name: frege-frontend-prod
    hostname: frege-frontend-prod
    ports: []
    expose:
      - ${DOCKER_FRONTEND_PORT}
    environment:
      - PORT=${DOCKER_FRONTEND_PORT}
      - REACT_APP_DOCKER_GRAFANA_HOST=frege-grafana-prod
      - REACT_APP_DOCKER_GRAFANA_PORT=3000
      - DOCKER_FLOWER_HOST=frege-flower-dev
      - DOCKER_FLOWER_PORT=5555
      - NODE_ENV=production
      - VIRTUAL_HOST=${FRONTEND_HOSTNAME}
      - LETSENCRYPT_HOST=${FRONTEND_HOSTNAME}
    depends_on:
      - frege-grafana-prod
    profiles: [ "prod" ]

  frege-backend-prod:
    <<: *backend
    container_name: frege-backend-prod
    command: >
      sh -c "python manage.py migrate --noinput
      && python manage.py initadmin
      && python manage.py collectstatic --noinput
      && gunicorn frege.wsgi:application --bind 0.0.0.0:${DOCKER_BACKEND_PORT}"
    volumes:
      - frege_tmp:${DJANGO_DOWNLOAD_PATH}
      - frege_static_files:/app/static
    profiles: [ "prod" ]
    ports: []
    expose:
      - ${DOCKER_BACKEND_PORT}
    environment:
      - VIRTUAL_HOST=${BACKEND_HOSTNAME}
      - LETSENCRYPT_HOST=${BACKEND_HOSTNAME}
    healthcheck:
      test: "curl -f http://localhost:${DOCKER_BACKEND_PORT}/ht || exit 1"
      interval: 10s
      timeout: 10s
      retries: 2

  frege-grafana-prod:
    <<: *grafana
    container_name: frege-grafana-prod
    environment:
      - GF_USERS_DEFAULT_THEME=dark
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_USERS_ALLOW_ORG_CREATE=false
      - GF_SECURITY_ADMIN_USER=${GF_SECURITY_ADMIN_USER}
      - GF_SECURITY_ADMIN_PASSWORD=${GF_SECURITY_ADMIN_PASSWORD}
      # - GF_AUTH_ANONYMOUS_ENABLED=true
      # - GF_SECURITY_ALLOW_EMBEDDING=true
      # - GF_SERVER_ROOT_URL=%(protocol)s://%(domain)s:%(http_port)s/grafana/
      # - GF_SERVER_SERVE_FROM_SUB_PATH=true
      - VIRTUAL_HOST=${FRONTEND_HOSTNAME}
      - LETSENCRYPT_HOST=${FRONTEND_HOSTNAME}
    profiles: [ "prod" ]
    expose:
      - ${DOCKER_FRONTEND_PORT}
    ports: []
    env_file: []

  frege-flower-prod:
    <<: *backend
    container_name: frege-flower-prod
    command: celery -A frege flower
    expose:
      - ${DOCKER_FLOWER_PORT}
    environment:
      CELERY_BROKER_URL: redis://frege-redis
      CELERY_RESULT_BACKEND: redis://frege-redis
    depends_on:
      - frege-celery-worker-prod
      - frege-celery-downloads-worker-prod
      - frege-celery-crawl-worker-prod
      - frege-redis
    profiles: [ "prod" ]
    healthcheck:
      test: "curl -f http://localhost:${DOCKER_FLOWER_PORT} || exit 1"
      interval: 10s
      timeout: 10s
      retries: 2

  frege-celery-crawl-worker-prod:
      <<: [*backend, *celery-healthcheck]
      container_name: frege-celery-crawl-worker-prod
      ports: []
      command: celery -A frege worker -Q crawl -l info --concurrency=${CELERY_WORKER_CRAWL_CONCURRENCY} -n worker_crawl
      profiles: [ "prod" ]

  frege-celery-downloads-worker-prod:
    <<: [*backend, *celery-healthcheck]
    container_name: frege-celery-downloads-worker-prod
    ports: []
    command: celery -A frege worker -Q downloads -l info --concurrency=${CELERY_WORKER_DOWNLOADS_CONCURRENCY} -n worker_downloads
    profiles: [ "prod" ]

  frege-celery-worker-prod:
    <<: [*backend, *celery-healthcheck]
    container_name: frege-celery-worker-prod
    ports: []
    command: celery -A frege worker -Q celery -l info --concurrency=${CELERY_WORKER_BASE_CONCURRENCY} -n worker_celery
    profiles: [ "prod" ]

  nginx-proxy:
    image: nginx
    # TODO: field below should be changed, but will require docker-gen
    #       reconfiguration in order for it to find this container properly
    container_name: nginx-proxy
    ports:
      - "${DOCKER_EGRESS_IP}:80:80"
      - "${DOCKER_EGRESS_IP}:443:443"
    volumes:
      - frege_proxy_conf:/etc/nginx/conf.d
      - frege_proxy_vhost:/etc/nginx/vhost.d
      - frege_proxy_html:/usr/share/nginx/html
      - frege_proxy_certs:/etc/nginx/certs:ro
      # TODO: this is a hack to get the nginx proxy to work with the django
      #       static files (currently there exists a blanket "api_static"
      #       location rule in egress.ngins.conf) - should be fixed
      - frege_static_files:/var/www/backend/static
    restart: always
    profiles: [ "prod" ]
    networks:
      - frege-main
    healthcheck:
      test: "curl -f localhost || exit 1"
      interval: 10s
      timeout: 10s
      retries: 2
      start_period: 1m

  docker-gen:
    image: nginxproxy/docker-gen
    container_name: frege-nginx-proxy-gen
    command: >
      -notify-sighup nginx-proxy
      -watch /etc/docker-gen/templates/nginx.tmpl /etc/nginx/conf.d/default.conf
    volumes_from:
      - nginx-proxy
    volumes:
      - ./nginx/egress.nginx.conf:/etc/docker-gen/templates/nginx.tmpl:ro
      - /var/run/docker.sock:/tmp/docker.sock:ro
    restart: on-failure
    profiles: [ "prod" ]
    networks:
      - frege-main

  frege-proxy-acme:
    image: nginxproxy/acme-companion:2.2
    container_name: frege-proxy-acme
    hostname: frege-proxy-acme
    restart: on-failure
    networks:
      - frege-main
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - frege_proxy_conf:/etc/nginx/conf.d
      - frege_proxy_vhost:/etc/nginx/vhost.d
      - frege_proxy_html:/usr/share/nginx/html
      - frege_proxy_certs:/etc/nginx/certs:rw
    environment:
      - DEFAULT_EMAIL=${LETSENCRYPT_EMAIL}
      - NGINX_PROXY_CONTAINER=frege-proxy
    profiles: [ "tls" ]

networks:
  frege-main:

volumes:
  frege_postgresql_data:
  frege_tmp:
  frege_grafana_storage:

  # Production
  frege_static_files:
  frege_proxy_conf:
  frege_proxy_vhost:
  frege_proxy_html:
  frege_proxy_certs:
